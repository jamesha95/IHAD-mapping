---
title: "Mapping the ABS experimental Index of Household Advantage and Disadvantage (IHAD)"
output: 
  html_document:
    code_folding: show
---
https://github.com/jamesha95/IHAD-mapping.git
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      results = "hide", 
                      message = FALSE,
                      warning = FALSE)
```

## Background

In 2019, the ABS released the experimental Index of Household Advantage and Disadvantage. This variable assigns a socio-economic score to each eligible household in the 2016 Census, and then allocates the households to a quartile (not population-weighted). 

This variable is not yet available in TableBuilder for cross-classification (as of March 25th, 2019). This is unfortunate; it would be very helpful to be able to investigate the relationship between socio-economic disadvantage and other characteristics. 

So far, the most disaggregated information available is only the percentage of households in each quartile, at the SA1 level. In this script, we will map the proportion of households in the bottom quartile for each SA1, and then aggregate to SA2 (weighting by household, and then by population to see if there's much difference). We may then further compare to SEIFA indices. 

IHAD may end up being nothing more than a slightly more nuanced version of SEIFA, where statistical areas are described not by one score but by four (that is, the proportion of households in each IHAD quartile). But hopefully it becomes available in TableBuilder in the near future to allow easy analysis of socio-economic disadvantage without the ecological validity issues of SEIFA.

To begin, we import the data from the [ABS website](https://www.abs.gov.au/AUSSTATS/abs@.nsf/DetailsPage/4198.02016?OpenDocument). We've named the file `sa1-ihad-percentages.xls` and stored it in the folder named `data`.

```{r Importing the data}

# Packages first

library(devtools)
#install_github("wfmackey/absmapsdata")

library(tidyverse)
library(sf)
library(absmapsdata)
library(grattantheme)
library(sp)
library(data.table)
library(ASGS)
library(tmap)
library(leaflet)
library(data.table)

# Now we read in the data from the website

download.file(url = "https://www.abs.gov.au/AUSSTATS/subscriber.nsf/log?openagent&statistical%20area%20level%201,%20percentage%20of%20households,%20ihad%202016.xls&4198.0&Data%20Cubes&DE8CAFA6829E80E6CA2583AD00106126&0&2016&26.02.2019&Latest",destfile = "ihad-percentages-sa1.xls")

data <- readxl::read_xls(path = "ihad-percentages-sa1.xls", 
                         sheet = "Table 1", 
                         skip = 5, 
                         col_names = TRUE)

# Now we tidy the column names 

data <- data %>%
  
# We note that column one is the 7-digit SA1 code, which is unhelpful and will be removed
  
  select(-...1) %>%
  
# And now we give sensible names to the remaining columns
  
  rename(sa1_main_2016 = ...2,
         percentage_q1 = `Quartile 1`,
         percentage_q2 = `Quartile 2`,
         percentage_q3 = `Quartile 3`,
         percentage_q4 = `Quartile 4`,
         dwellings_in_scope = ...7,
         SEIFA_quartile = ...8,
         population = ...9, 
         dwellings_total = ...10)

```

## Combining with map data

We now append this data to the `simple features` ABS map data synthesised by [Will Mackey](https://github.com/wfmackey/absmapsdata). 

```{r Joining with map data, echo=FALSE}

# We need to change the SA1 codes to be character rather than numeric

data <- data %>% 
  mutate(sa1_main_2016 = as.character(sa1_main_2016))

# Now we join the IHAD data onto the mapping data and filter for our capital cities of interest

ihad_sa1 <- full_join(sa12016, data, "sa1_main_2016") %>% 
  mutate(approx_number_q1_households = round(percentage_q1*dwellings_total/100))

ihad_sa1_melb <- ihad_sa1 %>% 
  filter(gcc_name_2016 == "Greater Melbourne")

ihad_sa1_syd <- ihad_sa1 %>% 
  filter(gcc_name_2016 == "Greater Sydney")

ihad_sa1_bris <- ihad_sa1 %>% 
  filter(gcc_name_2016 == "Greater Brisbane")

```

We've wrangled, now let us plot!

```{r Cartography 1: Plotting maps}
map_sa1_melb <- 
  ggplot(data = ihad_sa1_melb) +
  geom_sf(aes(geometry = geometry,
              fill = percentage_q1),
          lwd = 0) +
  scale_fill_gradientn(colours = grattan_pal(6)) +
  theme_grattan() +
  theme(legend.position = "right",
        legend.direction = "vertical") +
  coord_sf(datum = NA) +
  labs(title = "Disadvantage across Greater Melbourne", 
       subtitle = "Percentage of households in the bottom IHAD quartile",
       fill = "Percentage")

map_sa1_syd <- 
  ggplot(data = ihad_sa1_syd) +
  geom_sf(aes(geometry = geometry,
              fill = percentage_q1),
          lwd = 0) +
  scale_fill_gradientn(colours = grattan_pal(6)) +
  theme_grattan() +
  theme(legend.position = "right",
        legend.direction = "vertical") +
  coord_sf(datum = NA) +
  labs(title = "Disadvantage across Greater Sydney", 
       subtitle = "Percentage of households in the bottom IHAD quartile",
       fill = "Percentage")  

map_sa1_melb
map_sa1_syd
  


```

## Aggregating the data to SA2s or SA3s

Now that we've mapped the SA1s, we can see that several areas are unpopulated. We will now aggregate to the SA2 level, and try to increase interactivity in the map (hover to see the SA2 name). 

The proportion of households facing disadvantage (i.e. in the lowest quartile) can be determined by summing the number of disadvantaged households in each SA2 and dividing by the total number of in-scope households.

```{r Aggregating to SA2}

# We need to correspond the sa1 data to sa2s, then append to sa2 geometry.

corresp_sa1_to_sa2 <- tibble(sa1_main_2016 = sa12016$sa1_main_2016, 
                             sa2_main_2016 = sa12016$sa2_main_2016)

ihad_agg <- data %>% 
  full_join(corresp_sa1_to_sa2, by = "sa1_main_2016") %>% 
  mutate(n_q1 = percentage_q1*dwellings_in_scope/100,
         n_q2 = percentage_q2*dwellings_in_scope/100,
         n_q3 = percentage_q3*dwellings_in_scope/100,
         n_q4 = percentage_q4*dwellings_in_scope/100) %>% 
  group_by(sa2_main_2016) %>%
  summarise(n_q1 = sum(n_q1, na.rm = TRUE),
            n_q2 = sum(n_q2, na.rm = TRUE),
            n_q3 = sum(n_q3, na.rm = TRUE),
            n_q4 = sum(n_q4, na.rm = TRUE),
            dwellings_in_scope = sum(dwellings_in_scope, na.rm = TRUE),
            dwellings_total = sum(dwellings_total, na.rm = TRUE),
            population = sum(population, na.rm = TRUE)) %>% 
  mutate(percentage_q1 = 100*n_q1/dwellings_in_scope,
         approx_number_households = percentage_q1*dwellings_total/100) %>% 
  full_join(sa22016, by = "sa2_main_2016")
  
# One SA2 is a clear outlier - Braeside in Melbourne (100%). It has a low sample size, about 11 households. We exclude those SA2s with more than 60% of households in the bottom quartile.

ihad_sa2_melb <- ihad_agg %>% 
  filter(gcc_name_2016 == "Greater Melbourne")

ihad_sa2_melb_trim <- ihad_sa2_melb %>%
  mutate(percentage_q1 = ifelse(dwellings_total >= 100, round(percentage_q1, 2), NA)) # removes the shading from SA2s with low household counts

ihad_sa2_syd <- ihad_agg %>% 
  filter(gcc_name_2016 == "Greater Sydney")

ihad_sa2_syd_trim <- ihad_sa2_syd %>%
  mutate(percentage_q1 = ifelse(dwellings_total >= 100, round(percentage_q1, 2), NA)) # removes the shading from SA2s with low household counts

ihad_sa2_bris <- ihad_agg %>% 
  filter(gcc_name_2016 == "Greater Brisbane")

ihad_sa2_bris_trim <- ihad_sa2_bris %>%
  mutate(percentage_q1 = ifelse(dwellings_total >= 100, round(percentage_q1, 2), NA)) # removes the shading from SA2s with low household counts

```

```{r Aggregating to SA3}

# We need to correspond the sa1 data to sa2s, then append to sa2 geometry.

corresp_sa1_to_sa3 <- tibble(sa1_main_2016 = sa12016$sa1_main_2016, 
                             sa3_code_2016 = sa12016$sa3_code_2016)

ihad_agg_sa3 <- data %>% 
  full_join(corresp_sa1_to_sa3, by = "sa1_main_2016") %>% 
  mutate(n_q1 = percentage_q1*dwellings_in_scope,
         n_q2 = percentage_q2*dwellings_in_scope,
         n_q3 = percentage_q3*dwellings_in_scope,
         n_q4 = percentage_q4*dwellings_in_scope) %>% 
  group_by(sa3_code_2016) %>%
  summarise(n_q1 = sum(n_q1, na.rm = TRUE),
            n_q2 = sum(n_q2, na.rm = TRUE),
            n_q3 = sum(n_q3, na.rm = TRUE),
            n_q4 = sum(n_q4, na.rm = TRUE),
            dwellings_in_scope = sum(dwellings_in_scope, na.rm = TRUE),
            dwellings_total = sum(dwellings_total, na.rm = TRUE),
            population = sum(population, na.rm = TRUE)) %>% 
  mutate(percentage_q1 = n_q1/dwellings_in_scope,
         approx_number_households = percentage_q1*dwellings_total/100) %>% 
  full_join(sa32016, by = "sa3_code_2016")
  
#

ihad_sa3_melb <- ihad_agg_sa3 %>% 
  filter(gcc_name_2016 == "Greater Melbourne")

ihad_sa3_syd <- ihad_agg_sa3 %>% 
  filter(gcc_name_2016 == "Greater Sydney")

ihad_sa3_bris <- ihad_agg_sa3 %>% 
  filter(gcc_name_2016 == "Greater Brisbane")
```

Having wrangled, now we plot.

```{r Cartography 2: Plotting the SA2 maps, results="show"}

#I've set `results="show"` because without it, the interactive map won't print

map_sa2_melb <- 
  ggplot(data = ihad_sa2_melb) +
  geom_sf(aes(geometry = geometry,
              fill = percentage_q1),
          lwd = 0) +
  geom_point(aes(x = cent_lat,
                 y = cent_long,
                 size = approx_number_households),
             colour = "black",
             alpha = 0.5) +
  scale_size(range = c(0.1, 1)) +
  scale_fill_gradientn(colours = grattan_pal(6)) +
  theme_grattan() +
  theme(legend.position = "right",
        legend.direction = "vertical",
        axis.title = element_blank()) +
  coord_sf(datum = NA) +
  labs(title = "Disadvantage across Greater Melbourne", 
       subtitle = "Percentage of households in the bottom IHAD quartile",
       fill = "Percentage")
  
map_sa2_melb
 

# Re-ordering columns so that the label is the name, not the code
ihad_sa2_melb_leaflet <- ihad_sa2_melb %>% 
  select(sa2_name_2016, everything())

# getting the tibble ready for use in tmap
sf_sa2_melb <- st_as_sf(ihad_sa2_melb_leaflet)

tmap_mode("view")

int_map <- tm_shape(sf_sa2_melb) + 
  tm_fill(col = "percentage_q1", 
          palette = grattan_pal(6),
          alpha = 0.5) +
  tm_bubbles(size = "approx_number_households", 
             col = "black", 
             border.col = "white", 
             alpha = 0.5) +
  tm_borders(col = grattan_grey1, lwd = 0.5)

int_map


```

Next we'll try making a map with a dot plotted for every 50 or so households in the bottom quartile.

```{r Sampling dots within SA2s}

#  Let's try plotting one dot for every 50 households
#  Note that we do this only for Melbourne, as it's not our preferred technique (which is sampling from SA1s, in a later chunk)


perNhh <- 50
pointCollector <- list()

ihad_sa2_melb_trim <- ihad_sa2_melb %>%
  filter(percentage_q1 <= 60)

melb_sf <- SA2_2016
temp <- SA2_2016@data %>% as.data.table()
melb_sf@data <- temp[ , SA2_MAIN16 := SA2_MAIN16 %>% as.character()]
melb_sf <- melb_sf[melb_sf$GCC_NAME16 == "Greater Melbourne",]

for(i in ihad_sa2_melb_trim$sa2_main_2016){
  sa2_shape_frame <- melb_sf[melb_sf$SA2_MAIN16 == i, ]
  if(nrow(sa2_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa2_melb_trim$approx_number_households[ihad_sa2_melb_trim$sa2_main_2016 == i])){next()}
  npts <- floor(ihad_sa2_melb_trim$approx_number_households[ihad_sa2_melb_trim$sa2_main_2016 == i]/perNhh)
  if(npts == 0){next()}
  pts <- data.frame(spsample(x = sa2_shape_frame, 
                             n = npts, 
                             type = "random", 
                             iter = 10)@coords) # iter(default = 4): number of times to try to place sample points in a polygon before giving up and returning NULL - this may occur when trying to hit a small and awkwardly shaped polygon in a large bounding box with a small number of points.
  pointCollector[[i]] <- pts
}

pointFrame <- bind_rows(pointCollector, .id = "sa2_main")

```

And once again, we plot.

```{r Cartography 3: SA2 dot maps}

map_sa2_melb_dots <- ggplot(ihad_sa2_melb_trim)
map_sa2_melb_dots <- map_sa2_melb_dots + theme_void()
map_sa2_melb_dots <- map_sa2_melb_dots + geom_sf(aes(geometry = geometry, 
                                                     fill = percentage_q1),
                                                 lwd = 0)
map_sa2_melb_dots <- map_sa2_melb_dots + scale_fill_gradientn(colours = grattan_pal(6))
map_sa2_melb_dots <- map_sa2_melb_dots + geom_point(data = pointFrame,
                                                    aes(x = x, y = y),
                                                    shape = ".",
                                                    colour = "BLACK",
                                                    alpha = 1/2)
map_sa2_melb_dots <- map_sa2_melb_dots + theme(legend.position = "right", 
                                               legend.direction = "vertical",
                                               legend.text = element_text(size = 12),
                                               axis.title = element_blank())
map_sa2_melb_dots <- map_sa2_melb_dots + coord_sf(datum = NA)
map_sa2_melb_dots <- map_sa2_melb_dots + labs(title = "Disadvantage across Greater Melbourne", 
                                              subtitle = "Percentage of households in the bottom IHAD quartile",
                                              fill = "Percentage",
                                              shape = "50 households")

map_sa2_melb_dots

```

Next, let's try sampling the households within SA1s, but plotting onto the SA2 map. This ensures more accurate house-dot location.

```{r Sampling dots from SA1s}

#  Let's try plotting one dot for every 50 households 
# (works but very concentrated dots in inner-Melb). 

# Now let's try 100 
# (too few dots, SA1s are too small...)

# Okay let's go back to 50 but use a ceiling function
# Better, but a hist of approx_number_households shows that the average number is only 38, and the distribution is extremely skewed

# so let's try 10 with a `round` instead of a ceiling or floor. This could be too much
# and yeah, it's a lot

# next is to try 20
# still a lot

# we settle on 50 with a round feature (so SA1s with at least 25 households get a dot)

perNhh <- 50
pointCollector <- list()

# Create a shapefile for each capital
sa1_sf <- SA1_2016
temp <- SA1_2016@data %>% as.data.table()
sa1_sf@data <- temp[ , SA1_MAIN16 := SA1_MAIN16 %>% as.character()]
melb_sa1_sf <- sa1_sf[sa1_sf$GCC_NAME16 == "Greater Melbourne",]
syd_sa1_sf <- sa1_sf[sa1_sf$GCC_NAME16 == "Greater Sydney",]
bris_sa1_sf <- sa1_sf[sa1_sf$GCC_NAME16 == "Greater Brisbane",]

# We repeat the below code for each city, sampling household dots from the SA1s

# --- Melbourne ---

for(i in ihad_sa1_melb$sa1_main_2016){
  sa1_shape_frame <- melb_sa1_sf[melb_sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1_melb$approx_number_q1_households[ihad_sa1_melb$sa1_main_2016 == i])){next()}
  if(ihad_sa1_melb$approx_number_q1_households[ihad_sa1_melb$sa1_main_2016 == i] == 0){next()}
  npts <- round(ihad_sa1_melb$approx_number_q1_households[ihad_sa1_melb$sa1_main_2016 == i]/perNhh)
  if(npts == 0){next()}
  pts <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts,
                             type = "random",
                             iter = 10)@coords) # iter(default = 4): number of times to try to place sample points in a polygon before giving up and returning NULL - this may occur when trying to hit a small and awkwardly shaped polygon in a large bounding box with a small number of points.
  pointCollector[[i]] <- pts
}

pointFrameSA1melb <- bind_rows(pointCollector, .id = "sa1_main")
pointCollector <- list() # cleaning up after oneself
dim(pointFrameSA1melb) # just a check
head(pointFrameSA1melb)

# --- Sydney ---

for(i in ihad_sa1_syd$sa1_main_2016){
  sa1_shape_frame <- syd_sa1_sf[syd_sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1_syd$approx_number_q1_households[ihad_sa1_syd$sa1_main_2016 == i])){next()}
  if(ihad_sa1_syd$approx_number_q1_households[ihad_sa1_syd$sa1_main_2016 == i] == 0){next()}
  npts <- round(ihad_sa1_syd$approx_number_q1_households[ihad_sa1_syd$sa1_main_2016 == i]/perNhh)
  if(npts == 0){next()}
  pts <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts,
                             type = "random",
                             iter = 10)@coords) # iter(default = 4): number of times to try to place sample points in a polygon before giving up and returning NULL - this may occur when trying to hit a small and awkwardly shaped polygon in a large bounding box with a small number of points.
  pointCollector[[i]] <- pts
}

pointFrameSA1syd <- bind_rows(pointCollector, .id = "sa1_main")
pointCollector <- list() # cleaning up after oneself
dim(pointFrameSA1syd) # just a check
head(pointFrameSA1syd)

# --- Brisbane ---

for(i in ihad_sa1_bris$sa1_main_2016){
  sa1_shape_frame <- bris_sa1_sf[bris_sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1_bris$approx_number_q1_households[ihad_sa1_bris$sa1_main_2016 == i])){next()}
  if(ihad_sa1_bris$approx_number_q1_households[ihad_sa1_bris$sa1_main_2016 == i] == 0){next()}
  npts <- round(ihad_sa1_bris$approx_number_q1_households[ihad_sa1_bris$sa1_main_2016 == i]/perNhh)
  if(npts == 0){next()}
  pts <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts,
                             type = "random",
                             iter = 10)@coords) # iter(default = 4): number of times to try to place sample points in a polygon before giving up and returning NULL - this may occur when trying to hit a small and awkwardly shaped polygon in a large bounding box with a small number of points.
  pointCollector[[i]] <- pts
}

pointFrameSA1bris <- bind_rows(pointCollector, .id = "sa1_main")
pointCollector <- list() # cleaning up after oneself
dim(pointFrameSA1bris) # just a check
head(pointFrameSA1bris)

```
Once more unto the `plotting` breach!

```{r Cartography 4: Plotting SA1 dots on a static SA2 map}

# 

map_sa2_melb_dots <- ggplot(ihad_sa2_melb)
map_sa2_melb_dots <- map_sa2_melb_dots + theme_void()
map_sa2_melb_dots <- map_sa2_melb_dots + geom_sf(aes(geometry = geometry, 
                                                     fill = percentage_q1),
                                                 lwd = 0)
map_sa2_melb_dots <- map_sa2_melb_dots + scale_fill_gradientn(colours = grattan_pal(6))
map_sa2_melb_dots <- map_sa2_melb_dots + geom_point(data = pointFrameSA1melb,
                                                    aes(x = x, y = y),
                                                    shape = ".",
                                                    colour = "BLACK",
                                                    alpha = 1/2)
# I don't know why, but some sampled dots have coordinates (x,y) and some have coords (coords.x1, coords.x2). I should investigate and fix, but for now I'll just plot both.
map_sa2_melb_dots <- map_sa2_melb_dots + geom_point(data = pointFrameSA1melb,
                                                    aes(x = coords.x1, y = coords.x2),
                                                    shape = ".",
                                                    colour = "BLACK",
                                                    alpha = 1/2)
map_sa2_melb_dots <- map_sa2_melb_dots + theme(legend.position = "right", 
                                               legend.direction = "vertical",
                                               legend.text = element_text(size = 12),
                                               axis.title = element_blank())
map_sa2_melb_dots <- map_sa2_melb_dots + coord_sf(datum = NA)
map_sa2_melb_dots <- map_sa2_melb_dots + labs(title = "Disadvantage across Greater Melbourne", 
                                              subtitle = "Percentage of households in the bottom IHAD quartile",
                                              fill = "Percentage",
                                              shape = "50 households")

map_sa2_melb_dots 

```

Now we're getting fancy. We're simulating dots for groups of households at the SA1 level to ensure locational accuracy, but plotting them onto SA3s so that we can see the underlying colour better.

```{r Cartography 5: Plotting SA1 dots on a static SA3 map}

# 

map_melb_sa3_dots_sa1 <- ggplot(ihad_sa3_melb)
map_melb_sa3_dots_sa1 <- map_melb_sa3_dots_sa1 + theme_void()
map_melb_sa3_dots_sa1 <- map_melb_sa3_dots_sa1 + geom_sf(aes(geometry = geometry, 
                                                     fill = percentage_q1),
                                                 lwd = 0)
map_melb_sa3_dots_sa1 <- map_melb_sa3_dots_sa1 + scale_fill_gradientn(colours = grattan_pal(6))
map_melb_sa3_dots_sa1 <- map_melb_sa3_dots_sa1 + geom_point(data = pointFrameSA1melb,
                                                    aes(x = x, y = y),
                                                    shape = ".",
                                                    colour = "BLACK",
                                                    alpha = 1/2)
# I don't know why, but some sampled dots have coordinates (x,y) and some have coords (coords.x1, coords.x2). I should investigate and fix, but for now I'll just plot both.
map_melb_sa3_dots_sa1 <- map_melb_sa3_dots_sa1 + geom_point(data = pointFrameSA1melb,
                                                    aes(x = coords.x1, y = coords.x2),
                                                    shape = ".",
                                                    colour = "BLACK",
                                                    alpha = 1/2)
map_melb_sa3_dots_sa1 <- map_melb_sa3_dots_sa1 + theme(legend.position = "right", 
                                               legend.direction = "vertical",
                                               legend.text = element_text(size = 12),
                                               axis.title = element_blank(),
                                               plot.title = element_text(hjust = 0.5), 
                                               plot.subtitle = element_text(hjust = 0.5),
                                               plot.caption = element_text(hjust = 0.5)
                                               )
                                              
map_melb_sa3_dots_sa1 <- map_melb_sa3_dots_sa1 + coord_sf(datum = NA)
map_melb_sa3_dots_sa1 <- map_melb_sa3_dots_sa1 + labs(title = "Disadvantage across Greater Melbourne", 
                                              subtitle = "Percentage of households in the bottom IHAD quartile",
                                              fill = "Percentage",
                                              caption = "Each dot represents 50 households.\nBased on Grattan Institute analysis of ABS data.")

map_melb_sa3_dots_sa1

# grattan_save("Melbourne_Disadvantaged_Households.png", 
#              object = map_melb_sa3_dots_sa1,
#              type = "fullslide")

```

And lastly, I want to build an interactive version of the above map, with roads visible.

We may also want to do some spatial analysis, such as distance from nearest school or an overlap of the congestion scheme region and the number of disadvantaged households.

```{r Interactive map of Melbourne, results="show"}

# Removing the SA2s with few households (such as Braeside) and getting the file ready for tmap
sf_sa2_melb_trim <- ihad_sa2_melb %>% 
  select(sa2_name_2016, everything()) %>% 
  mutate(percentage_of_bottom_quartile_households = ifelse(dwellings_total >= 100, round(percentage_q1, 1), NA),
         approx_number_disadvantaged_households = round(approx_number_households),
         note = "One dot represents 50 households in the bottom quartile.") %>% 
  st_as_sf()

# and let's add an SA1 map below too.

sf_sa1_melb <- ihad_sa1_melb %>% 
  st_as_sf()

# now we convert the household locations into longitude and latitude

points_to_plot_melb <- pointFrameSA1melb %>% 
  mutate(x = ifelse(is.na(x), coords.x1, x),
         y = ifelse(is.na(y), coords.x2, y)) %>% 
  select(-c(coords.x1, coords.x2)) %>% 
   st_as_sf(coords = c('x', 'y'))

# and we plot!

tmap_mode("view")

int_map_sa1_melb <- tm_shape(sf_sa2_melb_trim) + 
  tm_fill(col = "percentage_of_bottom_quartile_households", 
          palette = grattan_pal(6),
          alpha = 0.5,
          popup.vars = c("sa2_name_2016", "sa3_name_2016", "percentage_of_bottom_quartile_households", "approx_number_disadvantaged_households", "note")) +
  tm_borders(col = grattan_grey1, lwd = 0.5) +
  
  tm_shape(sf_sa1_melb) + # this includes an SA1 map that can be turned on or off. But it also makes the file much larger and a bit slower. 
  tm_borders(col = "red") +
  
  tm_shape(points_to_plot_melb) +
  tm_dots(col = "black",
          size = 0.0001, #set to 0.1 or 0.01 if you turn on dot.size.fixed 
          shape = 16) +  #picks black circles
  
  tm_view(dot.size.fixed = FALSE) # prevents dots from scaling as you zoom

int_map_sa1_melb

 tmap_save(tm = int_map_sa1_melb, filename = "Interactive_map_of_disadvantage_in_Melbourne.html")

```

```{r Interactive map of Sydney, results="show"}

# Removing the SA2s with few households (such as Braeside) and getting the file ready for tmap
sf_sa2_syd_trim <- ihad_sa2_syd %>% 
  select(sa2_name_2016, everything()) %>% 
  mutate(percentage_of_bottom_quartile_households = ifelse(dwellings_total >= 100, round(percentage_q1, 1), NA),
         approx_number_disadvantaged_households = round(approx_number_households),
         note = "One dot represents 50 households in the bottom quartile.") %>% 
  st_as_sf()

# and let's add an SA1 map below too.

sf_sa1_syd <- ihad_sa1_syd %>% 
  st_as_sf()

# now we convert the household locations into longitude and latitude

points_to_plot_syd <- pointFrameSA1syd %>% 
  mutate(x = ifelse(is.na(x), coords.x1, x),
         y = ifelse(is.na(y), coords.x2, y)) %>% 
  select(-c(coords.x1, coords.x2)) %>% 
   st_as_sf(coords = c('x', 'y'))

# and we plot!

tmap_mode("view")

int_map_sa1_syd <- tm_shape(sf_sa2_syd_trim) + 
  tm_fill(col = "percentage_of_bottom_quartile_households", 
          palette = grattan_pal(6),
          alpha = 0.5,
          popup.vars = c("sa2_name_2016", "sa3_name_2016", "percentage_of_bottom_quartile_households", "approx_number_disadvantaged_households", "note")) +
  tm_borders(col = grattan_grey1, lwd = 0.5) +
  
  tm_shape(sf_sa1_syd) + # this includes an SA1 map that can be turned on or off. But it also makes the file much larger and a bit slower. 
  tm_borders(col = "red") +
  
  tm_shape(points_to_plot_syd) +
  tm_dots(col = "black",
          size = 0.0001, #set to 0.1 or 0.01 if you turn on dot.size.fixed 
          shape = 16) +  #picks black circles
  
  tm_view(dot.size.fixed = FALSE) # prevents dots from scaling as you zoom

int_map_sa1_syd

 tmap_save(tm = int_map_sa1_syd, filename = "Interactive_map_of_disadvantage_in_Sydney.html")

```

```{r Interactive map of Brisbane, results="show"}

# Removing the SA2s with few households (such as Braeside) and getting the file ready for tmap
sf_sa2_bris_trim <- ihad_sa2_bris %>% 
  select(sa2_name_2016, everything()) %>% 
  mutate(percentage_of_bottom_quartile_households = ifelse(dwellings_total >= 100, round(percentage_q1, 1), NA),
         approx_number_disadvantaged_households = round(approx_number_households),
         note = "One dot represents 50 households in the bottom quartile.") %>% 
  st_as_sf()

# and let's add an SA1 map below too.

sf_sa1_bris <- ihad_sa1_bris %>% 
  st_as_sf()

# now we convert the household locations into longitude and latitude

points_to_plot_bris <- pointFrameSA1bris %>% 
  mutate(x = ifelse(is.na(x), coords.x1, x),
         y = ifelse(is.na(y), coords.x2, y)) %>% 
  select(-c(coords.x1, coords.x2)) %>% 
   st_as_sf(coords = c('x', 'y'))

# and we plot!

tmap_mode("view")

int_map_sa1_bris <- tm_shape(sf_sa2_bris_trim) + 
  tm_fill(col = "percentage_of_bottom_quartile_households", 
          palette = grattan_pal(6),
          alpha = 0.5,
          popup.vars = c("sa2_name_2016", "sa3_name_2016", "percentage_of_bottom_quartile_households", "approx_number_disadvantaged_households", "note")) +
  tm_borders(col = grattan_grey1, lwd = 0.5) +
  
  tm_shape(sf_sa1_bris) + # this includes an SA1 map that can be turned on or off. But it also makes the file much larger and a bit slower. 
  tm_borders(col = "red") +
  
  tm_shape(points_to_plot_bris) +
  tm_dots(col = "black",
          size = 0.0001, #set to 0.1 or 0.01 if you turn on dot.size.fixed 
          shape = 16) +  #picks black circles
  
  tm_view(dot.size.fixed = FALSE) # prevents dots from scaling as you zoom

int_map_sa1_bris

 tmap_save(tm = int_map_sa1_bris, filename = "Interactive_map_of_disadvantage_in_Brisbane.html")

```

## Mapping advantage and disadvantage across capital cities

```{r Simulating households from all quartiles, nationally}


# 20 is wayyyyy to many, it makes the file ~100MB for all of Australia.
# Even 50 crashed it; the simulation took 20mins, and then we got an error saying that the file couldn't be opened...

perNhh <- 50
pointCollector <- list()

# Create one national shapefile
sa1_sf <- SA1_2016
temp <- SA1_2016@data %>% as.data.table()
sa1_sf@data <- temp[ , SA1_MAIN16 := SA1_MAIN16 %>% as.character()]
sa1_sf <- sa1_sf[sa1_sf$AREASQKM16 > 10^-4, ] # remove those pesky SA1s with zero area (like migratory - offshore or no usual address)


# Let's try to simulate the whole country at once and see if it works. 
# okay so the whole country fails to converge even with iter = 100. Let's restrict it to just the capital cities.

ihad_sa1 <- ihad_sa1 %>%
  mutate(approx_number_q2_households = round(dwellings_total*percentage_q2/100),
         approx_number_q3_households = round(dwellings_total*percentage_q3/100),
         approx_number_q4_households = round(dwellings_total*percentage_q4/100)) %>% 
  filter(areasqkm_2016 > 10^-4)

for(i in ihad_sa1$sa1_main_2016){
  sa1_shape_frame <- sa1_sf[sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1$approx_number_q1_households[ihad_sa1$sa1_main_2016 == i])){next()}
  if(ihad_sa1$approx_number_q1_households[ihad_sa1$sa1_main_2016 == i] == 0){next()}
  npts_q1 <- round(ihad_sa1$approx_number_q1_households[ihad_sa1$sa1_main_2016 == i]/perNhh)
  if(npts_q1 == 0){next()}
  pts_q1 <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts_q1,
                             type = "random",
                             iter = 10)@coords) 
  pointCollector[[i]] <- pts_q1
}
pointFrameq1 <- bind_rows(pointCollector, .id = "sa1_main") %>% 
  mutate(IHAD_quartile = as.factor(1))
pointCollector <- list() # cleaning up after oneself

for(i in ihad_sa1$sa1_main_2016){
  sa1_shape_frame <- sa1_sf[sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1$approx_number_q2_households[ihad_sa1$sa1_main_2016 == i])){next()}
  if(ihad_sa1$approx_number_q2_households[ihad_sa1$sa1_main_2016 == i] == 0){next()}
  npts_q2 <- round(ihad_sa1$approx_number_q2_households[ihad_sa1$sa1_main_2016 == i]/perNhh)
  if(npts_q2 == 0){next()}
  pts_q2 <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts_q2,
                             type = "random",
                             iter = 10)@coords) 
  pointCollector[[i]] <- pts_q2
}
pointFrameq2 <- bind_rows(pointCollector, .id = "sa1_main")%>% 
  mutate(IHAD_quartile = as.factor(2))
pointCollector <- list() # cleaning up after oneself

for(i in ihad_sa1$sa1_main_2016){
  sa1_shape_frame <- sa1_sf[sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1$approx_number_q3_households[ihad_sa1$sa1_main_2016 == i])){next()}
  if(ihad_sa1$approx_number_q3_households[ihad_sa1$sa1_main_2016 == i] == 0){next()}
  npts_q3 <- round(ihad_sa1$approx_number_q3_households[ihad_sa1$sa1_main_2016 == i]/perNhh)
  if(npts_q3 == 0){next()}
  pts_q3 <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts_q3,
                             type = "random",
                             iter = 10)@coords) 
  pointCollector[[i]] <- pts_q3
}
pointFrameq3 <- bind_rows(pointCollector, .id = "sa1_main") %>% 
  mutate(IHAD_quartile = as.factor(3))
pointCollector <- list() # cleaning up after oneself

for(i in ihad_sa1$sa1_main_2016){
  sa1_shape_frame <- sa1_sf[sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1$approx_number_q4_households[ihad_sa1$sa1_main_2016 == i])){next()}
  if(ihad_sa1$approx_number_q4_households[ihad_sa1$sa1_main_2016 == i] == 0){next()}
  npts_q4 <- round(ihad_sa1$approx_number_q4_households[ihad_sa1$sa1_main_2016 == i]/perNhh)
  if(npts_q4 == 0){next()}
  pts_q4 <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts_q4,
                             type = "random",
                             iter = 10)@coords) 
  pointCollector[[i]] <- pts_q4
}
pointFrameq4 <- bind_rows(pointCollector, .id = "sa1_main") %>% 
  mutate(IHAD_quartile = as.factor(4))
pointCollector <- list() # cleaning up after oneself


pointFrameSA1aus <- rbind(pointFrameq1, pointFrameq2, pointFrameq3, pointFrameq4)

dim(pointFrameSA1aus) # just a check
# head(pointFrameSA1aus)

randomly <- function(x) sample(xtfrm(x))

pointFrameSA1aus <- pointFrameSA1aus %>% 
  arrange(randomly(sa1_main))

corresp_sa1_to_gcc <- tibble(sa1_main = sa12016$sa1_main_2016, 
                             gcc_name_2016 = sa12016$gcc_name_2016)

pointFrameSA1aus <- pointFrameSA1aus %>% 
  full_join(corresp_sa1_to_gcc, by = "sa1_main")



```
And now we plot a giant map, covering all of Australia.

```{r Interactive map of all quartiles, results="show"}

# Removing the SA2s with few households (such as Braeside) and getting the file ready for tmap
sf_sa2_trim <- ihad_agg %>% 
  select(sa2_name_2016, everything()) %>% 
  mutate(percentage_of_bottom_quartile_households = ifelse(dwellings_total >= 100, round(percentage_q1, 1), NA),
         approx_total_households = round(dwellings_total),
         note = paste0("One dot represents ", perNhh, " households.")) %>% 
  st_as_sf()

# and let's add an SA1 map below too.

sf_sa1 <- ihad_sa1 %>% 
  st_as_sf()

# now we convert the household locations into longitude and latitude

points_to_plot_aus <- pointFrameSA1aus %>% 
  mutate(x = ifelse(is.na(x), coords.x1, x),
         y = ifelse(is.na(y), coords.x2, y)) %>% 
  select(-c(coords.x1, coords.x2)) %>%
  filter(is.na(x) == FALSE, is.na(y) == FALSE) %>% 
   st_as_sf(coords = c('x', 'y'))

# and we plot!

tmap_mode("view")

int_map_sa1_aus <- tm_shape(sf_sa2_trim) + 
  tm_fill(col = "white",  # this time, I don't actually want to shade anything in, I want to dot colour to do it
          alpha = 0,
          popup.vars = c("sa2_name_2016", "sa3_name_2016", "percentage_of_bottom_quartile_households", "approx_total_households", "note")) +
  tm_borders(col = grattan_grey1, 
             lwd = 0.5) +
  
  tm_shape(sf_sa1) + # this includes an SA1 map that can be turned on or off. But it also makes the file much larger and a bit slower. 
  tm_borders(col = "red") +
  
  tm_shape(points_to_plot_aus) +
  tm_dots(col = "IHAD_quartile",
          palette = grattan_pal(4, reverse = TRUE),
          border.alpha = 0,
          alpha = 0.5, 
          size = 0.0001, #set to 0.1 or 0.01 if you turn on dot.size.fixed 
          shape = 16) +  #picks black circles
  
  tm_view(dot.size.fixed = FALSE) # prevents dots from scaling as you zoom

# int_map_sa1_aus

 tmap_save(tm = int_map_sa1_aus, filename = paste0("Interactive_map_of_disadvantage_and_advantage_in_Australia_", perNhh, ".html"))

```

Plotting the whole country was way too ambitious. Let's break it down into capital cities only.

```{r Simulating households from all quartiles, by GCC}

# Set GCC to speed up the process

city = "Sydney"

# 20 is wayyyyy to many, it makes the file ~100MB for all of Australia.
perNhh <- 20
pointCollector <- list()

# Create one national shapefile
sa1_sf <- SA1_2016
temp <- SA1_2016@data %>% as.data.table()
sa1_sf@data <- temp[ , SA1_MAIN16 := SA1_MAIN16 %>% as.character()]
sa1_sf <- sa1_sf[sa1_sf$AREASQKM16 > 10^-4, ] # remove those pesky SA1s with zero area (like migratory - offshore or no usual address)

sa1_sf_gcc <- sa1_sf[sa1_sf$GCC_NAME16 == paste0("Greater ", city), ]

# Let's try to simulate the whole country at once and see if it works. 
# okay so the whole country fails to converge even with iter = 100. Let's restrict it to just the capital cities.

ihad_sa1_gcc <- ihad_sa1 %>%
  mutate(approx_number_q2_households = round(dwellings_total*percentage_q2/100),
         approx_number_q3_households = round(dwellings_total*percentage_q3/100),
         approx_number_q4_households = round(dwellings_total*percentage_q4/100)) %>% 
  filter(areasqkm_2016 > 10^-4,
         gcc_name_2016 == paste0("Greater ", city))

for(i in ihad_sa1_gcc$sa1_main_2016){
  sa1_shape_frame <- sa1_sf[sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1_gcc$approx_number_q1_households[ihad_sa1_gcc$sa1_main_2016 == i])){next()}
  if(ihad_sa1_gcc$approx_number_q1_households[ihad_sa1_gcc$sa1_main_2016 == i] == 0){next()}
  npts_q1 <- round(ihad_sa1_gcc$approx_number_q1_households[ihad_sa1_gcc$sa1_main_2016 == i]/perNhh)
  if(npts_q1 == 0){next()}
  pts_q1 <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts_q1,
                             type = "random",
                             iter = 10)@coords) 
  pointCollector[[i]] <- pts_q1
}
pointFrameq1 <- bind_rows(pointCollector, .id = "sa1_main") %>% 
  mutate(IHAD_quartile = as.factor(1))
pointCollector <- list() # cleaning up after oneself

for(i in ihad_sa1_gcc$sa1_main_2016){
  sa1_shape_frame <- sa1_sf[sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1_gcc$approx_number_q2_households[ihad_sa1_gcc$sa1_main_2016 == i])){next()}
  if(ihad_sa1_gcc$approx_number_q2_households[ihad_sa1_gcc$sa1_main_2016 == i] == 0){next()}
  npts_q2 <- round(ihad_sa1_gcc$approx_number_q2_households[ihad_sa1_gcc$sa1_main_2016 == i]/perNhh)
  if(npts_q2 == 0){next()}
  pts_q2 <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts_q2,
                             type = "random",
                             iter = 10)@coords) 
  pointCollector[[i]] <- pts_q2
}
pointFrameq2 <- bind_rows(pointCollector, .id = "sa1_main")%>% 
  mutate(IHAD_quartile = as.factor(2))
pointCollector <- list() # cleaning up after oneself

for(i in ihad_sa1_gcc$sa1_main_2016){
  sa1_shape_frame <- sa1_sf[sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1_gcc$approx_number_q3_households[ihad_sa1_gcc$sa1_main_2016 == i])){next()}
  if(ihad_sa1_gcc$approx_number_q3_households[ihad_sa1_gcc$sa1_main_2016 == i] == 0){next()}
  npts_q3 <- round(ihad_sa1_gcc$approx_number_q3_households[ihad_sa1_gcc$sa1_main_2016 == i]/perNhh)
  if(npts_q3 == 0){next()}
  pts_q3 <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts_q3,
                             type = "random",
                             iter = 10)@coords) 
  pointCollector[[i]] <- pts_q3
}
pointFrameq3 <- bind_rows(pointCollector, .id = "sa1_main") %>% 
  mutate(IHAD_quartile = as.factor(3))
pointCollector <- list() # cleaning up after oneself

for(i in ihad_sa1_gcc$sa1_main_2016){
  sa1_shape_frame <- sa1_sf[sa1_sf$SA1_MAIN16 == i, ]
  if(nrow(sa1_shape_frame) < 1){  next()  }
  if(is.na(ihad_sa1_gcc$approx_number_q4_households[ihad_sa1_gcc$sa1_main_2016 == i])){next()}
  if(ihad_sa1_gcc$approx_number_q4_households[ihad_sa1_gcc$sa1_main_2016 == i] == 0){next()}
  npts_q4 <- round(ihad_sa1_gcc$approx_number_q4_households[ihad_sa1_gcc$sa1_main_2016 == i]/perNhh)
  if(npts_q4 == 0){next()}
  pts_q4 <- data.frame(spsample(x = sa1_shape_frame,
                             n = npts_q4,
                             type = "random",
                             iter = 10)@coords) 
  pointCollector[[i]] <- pts_q4
}
pointFrameq4 <- bind_rows(pointCollector, .id = "sa1_main") %>% 
  mutate(IHAD_quartile = as.factor(4))
pointCollector <- list() # cleaning up after oneself


pointFrameSA1gcc <- rbind(pointFrameq1, pointFrameq2, pointFrameq3, pointFrameq4)

dim(pointFrameSA1gcc) # just a check


randomly <- function(x) sample(xtfrm(x))

pointFrameSA1gcc <- pointFrameSA1gcc %>% 
  arrange(randomly(sa1_main))

corresp_sa1_to_gcc <- tibble(sa1_main = sa12016$sa1_main_2016, 
                             gcc_name_2016 = sa12016$gcc_name_2016)

pointFrameSA1gcc <- pointFrameSA1gcc %>% 
  full_join(corresp_sa1_to_gcc, by = "sa1_main")



```

```{r Interactive map of all quartiles by GCC, results="show"}

# Let's get the files ready for tmap, and split them in GCCs

# We set the city in the last chunk.

sf_sa2_gcc_trim <- ihad_agg %>% 
  select(sa2_name_2016, everything()) %>% 
  mutate(percentage_of_bottom_quartile_households = ifelse(dwellings_total >= 100, round(percentage_q1, 1), NA),
         approx_total_households = round(dwellings_total),
         note = paste0("One dot represents ", perNhh, " households.")) %>% 
  filter(gcc_name_2016 == paste0("Greater ", city)) %>% 
  st_as_sf()

# and let's add an SA1 map below too.

sf_sa1_gcc <- ihad_sa1 %>% 
  filter(gcc_name_2016 == paste0("Greater ", city)) %>% 
  st_as_sf()

# now we convert the household locations into longitude and latitude

points_to_plot_gcc <- pointFrameSA1gcc %>%
  filter(gcc_name_2016 == paste0("Greater ", city)) %>% 
  mutate(x = ifelse(is.na(x), coords.x1, x),
         y = ifelse(is.na(y), coords.x2, y)) %>% 
  select(-c(coords.x1, coords.x2)) %>%
  filter(is.na(x) == FALSE, is.na(y) == FALSE) %>% 
   st_as_sf(coords = c('x', 'y'))

# and we plot!

tmap_mode("view")

int_map_sa1_gcc <- tm_shape(sf_sa2_gcc_trim) + 
  tm_fill(col = "white",  # this time, I don't actually want to shade anything in, I want to dot colour to do it
          alpha = 0,
          popup.vars = c("sa2_name_2016", "sa3_name_2016", "percentage_of_bottom_quartile_households", "approx_total_households", "note")) +
  tm_borders(col = grattan_grey1, 
             lwd = 0.5) +
  
  tm_shape(sf_sa1_gcc) + # this includes an SA1 map that can be turned on or off. But it also makes the file much larger and a bit slower. 
  tm_borders(col = "black") +
  
  tm_shape(points_to_plot_gcc) +
  tm_dots(col = "IHAD_quartile",
          palette = grattan_pal(4, reverse = TRUE),
          border.alpha = 0,
          alpha = 0.5, 
          size = 0.0005, #set to 0.1 or 0.01 if you turn on dot.size.fixed 
          shape = 16) +  #picks circles
  
  tm_view(dot.size.fixed = FALSE) # prevents dots from scaling as you zoom

# int_map_sa1_aus

 tmap_save(tm = int_map_sa1_gcc, filename = paste0("Interactive_map_of_disadvantage_and_advantage_in_", city, "_", perNhh, "_unfixed.html"))

```